(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{338:function(e,r,s){"use strict";s.r(r);var i=s(10),t=Object(i.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"_2-3-2-promise的几个关键问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2-promise的几个关键问题"}},[e._v("#")]),e._v(" 2.3.2 promise的几个关键问题")]),e._v(" "),r("h3",{attrs:{id:"如何改变promise的状态"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何改变promise的状态"}},[e._v("#")]),e._v(" 如何改变promise的状态？")]),e._v(" "),r("ol",[r("li",[e._v("resolve(value):如果当时是pending就会变成resolved")]),e._v(" "),r("li",[e._v("reject(reason): 如果当时是pending就会变成rejected")]),e._v(" "),r("li",[e._v("抛出异常：如果当时是pending就会变成rejected")])]),e._v(" "),r("h3",{attrs:{id:"一个promise指定多个成功-失败回调函数-都会调用吗"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一个promise指定多个成功-失败回调函数-都会调用吗"}},[e._v("#")]),e._v(" 一个Promise指定多个成功/失败回调函数，都会调用吗？")]),e._v(" "),r("ol",[r("li",[e._v("当Promise改变为对应状态时都会调用")])]),e._v(" "),r("h3",{attrs:{id:"改变promise状态和指定回调函数谁先谁后"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#改变promise状态和指定回调函数谁先谁后"}},[e._v("#")]),e._v(" 改变promise状态和指定回调函数谁先谁后")]),e._v(" "),r("ol",[r("li",[e._v("都有可能，正常情况下是先指定回调再改变状态，但也可以先改变状态再指定回调")]),e._v(" "),r("li",[e._v("如何先改状态再指定回调？\n"),r("ol",[r("li",[e._v("在执行器中直接调用resolve()/reject()")]),e._v(" "),r("li",[e._v("延迟更长时间才能调用then()")])])]),e._v(" "),r("li",[e._v("什么时候才能得到数据？\n"),r("ol",[r("li",[e._v("如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据")]),e._v(" "),r("li",[e._v("如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据")])])])]),e._v(" "),r("h3",{attrs:{id:"promise-then-返回的新promise的结果状态由什么决定"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-then-返回的新promise的结果状态由什么决定"}},[e._v("#")]),e._v(" promise.then()返回的新promise的结果状态由什么决定")]),e._v(" "),r("ol",[r("li",[e._v("简单表达：由then()指定的回调函数执行的结果决定")]),e._v(" "),r("li",[e._v("详细表述：\n"),r("ol",[r("li",[e._v("如果抛出异常，新promise变为rejected，reason为抛出的异常")]),e._v(" "),r("li",[e._v("如果返回的是非promise的任意值，新promise变为resolved，value为返回的值")]),e._v(" "),r("li",[e._v("如果返回的是一个新promise，此promise的结果就会成为新promise结果")])])])]),e._v(" "),r("h3",{attrs:{id:"promise如何串连多个操作任务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise如何串连多个操作任务"}},[e._v("#")]),e._v(" promise如何串连多个操作任务")]),e._v(" "),r("ol",[r("li",[e._v("promise的then()返回一个新的promise，可以开发程then()的链式调用")]),e._v(" "),r("li",[e._v("通过then的链式调用串连多个同步/异步任务")])]),e._v(" "),r("h3",{attrs:{id:"promise异常穿透"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise异常穿透"}},[e._v("#")]),e._v(" promise异常穿透？")]),e._v(" "),r("ol",[r("li",[e._v("当使用promise的then链式调用时，可以在最后指定失败的回调")]),e._v(" "),r("li",[e._v("前面任何操作除了异常，都会传到最后失败的回调中去处理")])]),e._v(" "),r("h3",{attrs:{id:"中断promise链"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#中断promise链"}},[e._v("#")]),e._v(" 中断promise链")]),e._v(" "),r("ol",[r("li",[e._v("当使用promise的then链式调用时，在中间中断，不再调用后面的回调函数")]),e._v(" "),r("li",[e._v("方法：在回调函数中返回一个pendding状态的 promise")])])])}),[],!1,null,null,null);r.default=t.exports}}]);